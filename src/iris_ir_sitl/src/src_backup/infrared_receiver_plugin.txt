#include <gazebo/gazebo.hh>
#include <gazebo/physics/physics.hh>
#include <gazebo/common/common.hh>
#include <ros/ros.h>
#include <geometry_msgs/Vector3.h>
#include <std_msgs/Float32.h>
#include <map>
#include <cmath>
#include <mutex>

//å•æ¥æ”¶å™¨ç‰ˆæœ¬ï¼Œ2025/11/04 11:30


namespace gazebo
{
// å…¨å±€æ ‡å¿—ï¼Œè¡¨ç¤ºROSæ˜¯å¦å·²åˆå§‹åŒ–
static bool g_ros_initialized_receiver = false;
static std::mutex g_ros_mutex_receiver;

class InfraredReceiverPlugin : public ModelPlugin
{
public:
    InfraredReceiverPlugin() : 
        model(nullptr), 
        updateCount(0),
        discoveryCount(0) 
    {}

    void Load(physics::ModelPtr _model, sdf::ElementPtr _sdf)
    {
        // å­˜å‚¨æ¨¡å‹æŒ‡é’ˆ
        this->model = _model;
        if (!this->model) {
            gzerr << "Received NULL model pointer!" << std::endl;
            return;
        }

        this->modelName = this->model->GetName();
        gzmsg << "ğŸ¯ === InfraredReceiverPlugin Loading for: " << this->modelName << " ===" << std::endl;

        // å®‰å…¨åˆå§‹åŒ–ROS
        if (!this->initializeROS()) {
            gzerr << "âŒ Failed to initialize ROS for receiver " << this->modelName << std::endl;
            return;
        }

        // è¿æ¥æ›´æ–°äº‹ä»¶
        this->updateConnection = event::Events::ConnectWorldUpdateBegin(
            std::bind(&InfraredReceiverPlugin::OnUpdate, this, std::placeholders::_1));

        // åˆ›å»ºå®šæ—¶å™¨æ¥å‘ç°å…¶ä»–æ— äººæœº
        this->discoveryTimer = this->rosNode->createTimer(
            ros::Duration(3.0), &InfraredReceiverPlugin::DiscoverOtherUavs, this);

        gzmsg << "ğŸ‰ === InfraredReceiverPlugin SUCCESS for: " << this->modelName << " ===" << std::endl;
    }

private:
    bool initializeROS()
    {
        std::lock_guard<std::mutex> lock(g_ros_mutex_receiver);
        
        // å¦‚æœROSå·²ç»åˆå§‹åŒ–ï¼Œç›´æ¥åˆ›å»ºèŠ‚ç‚¹
        if (g_ros_initialized_receiver) {
            return this->createROSNode();
        }
        
        // ç¬¬ä¸€æ¬¡åˆå§‹åŒ–ROS
        std::string node_name = "infrared_receiver_master";
        gzmsg << "Initializing ROS for receiver with node: " << node_name << std::endl;
        
        int argc = 0;
        char **argv = NULL;
        
        // ä½¿ç”¨NoSigintHandleré¿å…ä¿¡å·å¤„ç†å†²çª
        ros::init(argc, argv, node_name, ros::init_options::NoSigintHandler);
        
        if (!ros::master::check()) {
            gzerr << "ROS master is not running!" << std::endl;
            return false;
        }
        
        g_ros_initialized_receiver = true;
        gzmsg << "âœ… ROS initialized successfully for receivers" << std::endl;
        
        return this->createROSNode();
    }
    
    bool createROSNode()
    {
        try {
            // åˆ›å»ºèŠ‚ç‚¹å¥æŸ„
            this->rosNode.reset(new ros::NodeHandle());
            
            // åˆ›å»ºå‘å¸ƒå™¨ - è·ç¦»å’Œå¼ºåº¦
            std::string distance_topic = "/uav/infrared/receiver/distance_" + this->modelName;
            std::string strength_topic = "/uav/infrared/receiver/strength_" + this->modelName;
            
            this->distancePub = this->rosNode->advertise<std_msgs::Float32>(distance_topic, 10);
            this->strengthPub = this->rosNode->advertise<std_msgs::Float32>(strength_topic, 10);
            
            gzmsg << "âœ… Receiver " << this->modelName << " publishing to:" << std::endl;
            gzmsg << "   Distance: " << distance_topic << std::endl;
            gzmsg << "   Strength: " << strength_topic << std::endl;
            
            return true;
            
        } catch (const std::exception& e) {
            gzerr << "âŒ Failed to create ROS node for receiver: " << e.what() << std::endl;
            return false;
        }
    }

    void DiscoverOtherUavs(const ros::TimerEvent& event)
    {
        if (!this->rosNode) return;

        discoveryCount++;
        
        // æ¯3æ¬¡å‘ç°æ‰è¾“å‡ºä¸€æ¬¡æ—¥å¿—ï¼Œé¿å…å¤ªé¢‘ç¹
        if (discoveryCount % 3 == 1) {
            gzmsg << "ğŸ” Receiver " << this->modelName << " discovering other UAVs (attempt " << discoveryCount << ")..." << std::endl;
        }

        // è·å–æ‰€æœ‰å·²å‘å¸ƒçš„çº¢å¤–å‘å°„å™¨è¯é¢˜
        ros::master::V_TopicInfo topics;
        ros::master::getTopics(topics);
        
        int new_subscriptions = 0;
        for (const auto& topic : topics) {
            std::string topic_name = topic.name;
            
            // æŸ¥æ‰¾çº¢å¤–å‘å°„å™¨è¯é¢˜
            if (topic_name.find("/uav/infrared/emitter/") != std::string::npos) {
                // æå–æ— äººæœºåç§°
                size_t pos = topic_name.find_last_of("/");
                std::string uav_name = topic_name.substr(pos + 1);
                
                // å¦‚æœä¸æ˜¯è‡ªå·±ä¸”å°šæœªè®¢é˜…
                if (uav_name != this->modelName && 
                    this->otherUavSubscriptions.find(uav_name) == this->otherUavSubscriptions.end()) {
                    
                    // è®¢é˜…è¿™ä¸ªæ— äººæœºçš„è¯é¢˜
                    try {
                        ros::Subscriber sub = this->rosNode->subscribe<geometry_msgs::Vector3>(
                            topic_name, 10,
                            boost::bind(&InfraredReceiverPlugin::OnOtherUavSignal, this, _1, uav_name));
                        
                        this->otherUavSubscriptions[uav_name] = sub;
                        new_subscriptions++;
                        
                        if (discoveryCount % 3 == 1) {
                            gzmsg << "   âœ… Subscribed to: " << uav_name << std::endl;
                        }
                    } catch (const std::exception& e) {
                        gzerr << "   âŒ Failed to subscribe to " << uav_name << ": " << e.what() << std::endl;
                    }
                }
            }
        }
        
        if (new_subscriptions > 0 && discoveryCount % 3 == 1) {
            gzmsg << "   ğŸ“¡ Total subscriptions: " << this->otherUavSubscriptions.size() << std::endl;
        }
    }
    
    void OnOtherUavSignal(const geometry_msgs::Vector3::ConstPtr& msg, const std::string& emitter_name)
    {
        // å­˜å‚¨å…¶ä»–æ— äººæœºçš„ä½ç½®ä¿¡æ¯
        std::lock_guard<std::mutex> lock(this->dataMutex);
        this->otherUavPositions[emitter_name] = *msg;
    }
    
    void OnUpdate(const common::UpdateInfo &_info)
    {
        // å®‰å…¨æ£€æŸ¥
        if (!this->model || !this->rosNode || !this->distancePub || !this->strengthPub) {
            return;
        }

        // åˆå§‹åŒ–æ—¶é—´
        if (this->lastUpdateTime == common::Time::Zero) {
            this->lastUpdateTime = _info.simTime;
        }

        // æ§åˆ¶æ›´æ–°é¢‘ç‡ (2Hz)
        double updateRate = 2.0;
        if ((_info.simTime - this->lastUpdateTime).Double() < 1.0 / updateRate) {
            return;
        }
        this->lastUpdateTime = _info.simTime;

        // è·å–æ¥æ”¶å™¨ä½ç½®
        ignition::math::Pose3d receiverPose = this->model->WorldPose();
        ignition::math::Vector3d receiverPos = receiverPose.Pos();

        std::lock_guard<std::mutex> lock(this->dataMutex);
        
        // è®¡ç®—ä¸æ‰€æœ‰å…¶ä»–æ— äººæœºçš„ç»¼åˆè·ç¦»å’Œä¿¡å·å¼ºåº¦
        double totalDistance = 0.0;
        double totalStrength = 0.0;
        int validSignals = 0;

        for (const auto& pair : this->otherUavPositions) {
            const std::string& emitter_name = pair.first;
            const geometry_msgs::Vector3& emitter_pos = pair.second;
            
            // è®¡ç®—è·ç¦»
            double dx = emitter_pos.x - receiverPos.X();
            double dy = emitter_pos.y - receiverPos.Y();
            double dz = emitter_pos.z - receiverPos.Z();
            double distance = sqrt(dx*dx + dy*dy + dz*dz);
            
            double range = 15.0; // æœ€å¤§æ£€æµ‹èŒƒå›´
            
            // æ£€æŸ¥æ˜¯å¦åœ¨æœ‰æ•ˆèŒƒå›´å†…
            if (distance <= range && distance > 0.1) {
                // è®¡ç®—ä¿¡å·å¼ºåº¦ï¼ˆä¸è·ç¦»å¹³æ–¹æˆåæ¯”ï¼‰
                double strength = 1.0 / (1.0 + distance * distance);
                
                totalDistance += distance;
                totalStrength += strength;
                validSignals++;
            }
        }
        
        // å‘å¸ƒç»¼åˆä¿¡æ¯
        if (validSignals > 0) {
            // å¹³å‡è·ç¦»
            std_msgs::Float32 distanceMsg;
            distanceMsg.data = totalDistance / validSignals;
            this->distancePub.publish(distanceMsg);
            
            // æ€»ä¿¡å·å¼ºåº¦
            std_msgs::Float32 strengthMsg;
            strengthMsg.data = totalStrength;
            this->strengthPub.publish(strengthMsg);
            
            // å‡å°‘æ—¥å¿—é¢‘ç‡
            if (this->updateCount % 20 == 0) {
                gzmsg << "ğŸ“Š Receiver " << this->modelName << ": " 
                      << validSignals << " UAVs detected, avg_distance=" 
                      << std::fixed << std::setprecision(2) << distanceMsg.data 
                      << "m, total_strength=" << std::setprecision(4) << strengthMsg.data << std::endl;
            }
        } else {
            // æ²¡æœ‰æ£€æµ‹åˆ°ä¿¡å·
            std_msgs::Float32 distanceMsg;
            distanceMsg.data = -1.0;  // æ— æ•ˆè·ç¦»
            this->distancePub.publish(distanceMsg);
            
            std_msgs::Float32 strengthMsg;
            strengthMsg.data = 0.0;
            this->strengthPub.publish(strengthMsg);
            
            // å‡å°‘æ—¥å¿—é¢‘ç‡
            if (this->updateCount % 40 == 0) {
                gzmsg << "ğŸ”‡ Receiver " << this->modelName << ": no signals detected" << std::endl;
            }
        }
        
        this->updateCount++;
    }

    physics::ModelPtr model;
    std::string modelName;
    event::ConnectionPtr updateConnection;
    std::unique_ptr<ros::NodeHandle> rosNode;
    
    // å‘å¸ƒå™¨
    ros::Publisher distancePub;
    ros::Publisher strengthPub;
    
    // è®¢é˜…å™¨ç®¡ç†
    std::map<std::string, ros::Subscriber> otherUavSubscriptions;
    std::map<std::string, geometry_msgs::Vector3> otherUavPositions;
    std::mutex dataMutex;
    
    // å®šæ—¶å™¨
    ros::Timer discoveryTimer;
    
    common::Time lastUpdateTime;
    int updateCount;
    int discoveryCount;
};

GZ_REGISTER_MODEL_PLUGIN(InfraredReceiverPlugin)
}